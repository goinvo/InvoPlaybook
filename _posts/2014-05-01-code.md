---
layout: post
title: Code
---

## Version Control
Involution frequently develops software as part of a client engagement. This might be code for an internal project, a prototype for a client, or production code for a client. **Using [version control](http://en.wikipedia.org/wiki/Revision_control) is a studio requirement for any project involving software development**

### Before Creating a Repository
There's a few things to consider before creating a rpository. Primarily, based on information from early meetings and interactions with the client, we need to determine whether the code lives in one of our repositories or needs to be in theirs.

#### Client Hosted Version Control
If you are working with a client, ask the client if they prefer that we use their version control system (VCS). A client may need us to work with their VCS due to the proprietary nature of their software, privacyobligations to their clients or members, or myriad other reasons. If this is the case, follow up with the client contact on how to gain access to this system, any documentation they may have on their VCS or process, and possibly a good time to get a walkthrough of their process. In this case, the client will need to create a repository for us to work with.

#### Invo Hosted Version Control
If the project you are working on is internal or the client does not request that we use their version control system, we will use a git repository hosted at Github. This should be our preferred way of working, so we can offer a consistent experience from client to client and project to project.

Some other useful questions to ask up front include:

* Who will need access to the repository? Invo staff only? The client? Other third parties?
* Does the upcoming engagement extend existing code? Do we have a repository that might be appropriate already?
* Does the project leverage code (dependencies) from other repositories? (They need not be ours.)

### Creating a Repository on Github
Github has some [good documentation](https://help.github.com/articles/create-a-repo/) on how to create a repository. Here are a few things to note.

(If you're using [Github for Mac](https://mac.github.com/) you can use `CMD+N` and proceed as outlined at the URL above)

#### Private vs Public
Because of Involution's commitment to open source software, we default repositories to be public whenever possible. When working on an internal project, quickly double-check with the powers that be whether it is okay to make the repository public. **Always check with the client before creating a public repository on their behalf.**

#### Open Source Licenses
If the repository is public, make sure to include a License. We generally use [Apache 2.0](http://choosealicense.com/licenses/apache-2.0/), but check out [this site from Github](http://choosealicense.com/) for some help.

#### Naming Conventions
When naming a repository on Github, make the name [Pascal case](http://en.wikipedia.org/wiki/CamelCase) (camel case with the first letter capitalized). 

##### Client Repository Names
The repository name should start with the client's name and contain their product name (when relevant) as well as the project. Below are some examples:

* **CodeRyteHSCUI**: The UI code for the HSC product created by CodeRyte.
* **DataXuCampaignCreationPrototype**:The campaign creation prototype code for DataXu. In this case, they don't have a separate product name so it is not included. CampaignCreationPrototype describes the project.

##### Internal Project Repository Names
For projects that are owned by Invo, it is not necessary to include `Invo` in the repository title. In this case, give the repository a name which describes the software as a product. For example:

* **BatchIDMLGenerator**: A tool, developed by Involution, which generates batches of IDML files.
* **HealthAxioms**: The Health Axioms.
* **InvoLive**: In this case, the word Invo is included because we call the product "InvoLive" and not just "Live".

#### Access 

## Git Workflow
### Branching and Merging
We generally model our branching and merging strategy for projects off of the model outlined in [this article](http://nvie.com/posts/a-successful-git-branching-model/). Unless you have a strong reason to deviate (i.e. a client prefers a different workflow or you aren't using git), you should probably use this workflow.

### Releasing Source Code
**Whenever you release source code to a client, or push it to a production server, you should tag that release in git**. It is tedious to tag releases, but it is almost always a good idea. If there is some sort of additional work done as part of a "release" (i.e. adding `.mobileprovision` files or packaging an iOS application as an `IPA`), use the release functionality of Github to upload those extra dependencies.

## Evaluating APIs
These are some things we should check for when reviewing APIs to provide feedback.

### URL

* Is the URL understandable to someone who knows the subject matter?
* Are we using nouns instead of verbs (when possible)?
* Is the right HTTP verb being used based on the API standard (i.e. POST for create, PUT for edit, GET on the root for a list, GET with ID for the individual, DELETE for removal)
* Is the URL for the correct resource. For instance, When we POST, are we creating an object of the type at the end of the URL in the context of the previous part of the URL?

### Request/Response Data Structure

* What is the structure of the data?
* Within the request/response, how are relationships between objects being related. Nested structure? Linked by id? When making links between things, we should be using IDs and not names or titles, when possible.
* What fields do we need ids for? A good indicator of this is whether there is any action associated with the data element (such as a link).
* Is everything consistent? This includes names of fields, capitalization, data types. Does the same word elsewhere in the API mean the same thing?
* Are the values of the correct type? If something can only be 1 or 0, it should be a boolean. If it can only be a number, it should be a number and not a string.

### API Functionality

* Is there server side pagination? If so, then there must also be server side sorting and filtering. If not, then we can do client side filtering/sorting.
* Are we being forced to do string comparisons to find what we are looking for? Can that become an enum or can that represented in a different way? 


### Related Work

* Do we need to handle any other CRUD actions as part of this work? Is there a need to Edit or Delete as well?
* How will be able to verify that this is functional? If there is a POST, we should also have a GET.

### Workflow

* How often will we need to call this API? Should we be building this as a bulk operation instead?
* What other APIs are related to this resource? Can we combine them?
* Does this API feel like a waste of an XHR call?


### Tips on Communication 

* Assume that the person on the other end is a smart and capable engineer. Rather than telling them something they decided is wrong, ask for why they decided to do something in the way they did. There is probably a technical constraint or a business constraint that made them choose to do that. If not, it will be easier to suggest a change if you didn't tell them they were dumb.
* Make suggestions instead of demands. "I wonder if we could..."
* Remember that you might be wrong. Admit it when you are... and in many cases, assume you are.
* Try to be realistic in your assumptions. This is especially true when you are estimating sizes of payloads. If 98% of the time there is going to be less than 100 items, don't make the argument about the case with over 9000 just because you can.
* It is all about tradeoffs. The team won't always make the right decision and won't always make the decision you want. Choose your battles.

## Other Useful Tools
### Validating APIs
When developing and debugging API based applications it is sometimes useful to test the API independent of the UI codebase. There are a few tools which help make this possible:

#### Postman
[Postman](https://www.getpostman.com/) provides a [free Chrome extension](https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop) which lets you execute HTTP requests from your browser. At its core, it is an in-browser wrapper for [curl](http://curl.haxx.se/). A few things to note that makes Postman especially powerful:

* Postman will automatically grab the cookies from your browser
* Postman circumvents [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) (because it actually operates as a program and not as a website making asynchronous requests).
* Postman lets you set arbitrary HTTP headers (which is necessary for many authentication systems)
* You can save requests in collections (and even share them with your colleagues). This makes it easy to reproduce tests.

If you are having trouble making an API request within your application, it is useful to try to test it from Postman. This can isolate whether it is an issue with your code or an issue due to CORS configuration.

#### Charles
[Charles](http://www.charlesproxy.com/) is a cross-platform HTTP monitor and proxy. It will capture all network traffic on your computer and allow you to inspect the individual HTTP requests that are being made by your application.  A few notes:

* Charles is great for debugging network issues with your actual application. It allows you to see the requests in a similar way that the Chrome Developer Tools Network Tab does.
* If developing a native mobile or tablet application, you can configure your computer as a proxy and see the device's network traffic in Charles. This is really useful for native applications which don't have the luxury of using your web browser's developer tools.
* It is possible to view HTTPS requests, but you must provide the appropriate certificates (Google for more information)

#### Chrome Developer Tools
I find that the Chrome Developer Tools are feature rich and friendly than the Safari or Firefox developer tools. There's a bunch of documentation online about how to use them.

* If your application/website feels laggy, usually the Profiler can help your track down the issue in your code.
* The javascript debugger is really handy in identifying when methods get called. Keep in mind that you can run code during a debug statement by pulling up the console.
* You can remotely debug a WebView on your phone or tablet (in Chrome but also in Safari). This could be inspecting a website in your phone's browser or looking at a WebView in a native application. This is extremely powerful as phones oftentimes do weird things with CSS.

#### Creating UML Diagrams
A [UML Sequence Diagram](https://en.wikipedia.org/wiki/Sequence_diagram) is worth a thousand words (or an hour on the phone). They can very quickly show high level concepts of communication as well as surfacing the details. UML Class diagrams are also really useful for showing relationships between objects.

* [WebSequenceDiagrams.com](https://www.websequencediagrams.com/) is a GREAT tool for creating sequence diagrams. Write some text and it renders out the diagram. It is way quicker than using OmniGraffle or any of the purpose built GUIs for making UML diagrams. It is worth making a free account because then you can create folders of sequence diagrams(which you can share with other people)
* I have played with using [GraphViz](http://www.graphviz.org/) for making UML Class Diagrams. There isn't any tool that I have found that is perfect for it, but there are several online renderers. You can also check out [this blog post](http://www.ffnn.nl/pages/articles/media/uml-diagrams-using-graphviz-dot.php) for more information about how to do this.

#### Formatting and Validating JSON

* There are dozens of JSON validators and formatters online. I tend to use [this one](http://jsonformatter.curiousconcept.com/). It handles large JSON payloads pretty well and does a good job of pointing out the issues in your JSON.
* If you haven't installed [JSONView for Chrome](https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc?hl=en), do it now. It makes any JSON responses in your browser pretty.

#### Scraping Data from Websites
Sometimes, you might want to scrape data from a website or web request to look at it more closely. Here are some techniques for doing so:

* If the data is coming over an HTTP request, you can use the Developer Tools in your browser to view the response. 
* If the data is just visible on the screen, you can use [ScreenScraper](https://chrome.google.com/webstore/detail/screenscraper/pfegffhjcgkneoemnlniggnhkfioidjg/support?hl=en) (built and not maintained by Invo'ite Ben Salinas). It lets you use CSS selectors to grab data from a website and download it as a CSV or JSON file.
* For more complex websites, you can use [Kimono](https://www.kimonolabs.com/). This is a web app (and Chrome extension) that lets you turn data from a website into an API.
